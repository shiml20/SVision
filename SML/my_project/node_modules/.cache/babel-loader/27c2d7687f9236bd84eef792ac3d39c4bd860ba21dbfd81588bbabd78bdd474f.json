{"ast":null,"code":"import { IS_BROWSER } from '../../constants/env';\nimport { isNumber, isObject, isString } from '../../utils/inspect';\nimport { mathRound } from '../../utils/math';\nimport { toInteger } from '../../utils/number';\nimport { keys } from '../../utils/object';\nimport { getEventRoot } from '../../utils/get-event-root';\nimport { getInstanceFromDirective } from '../../utils/get-instance-from-directive';\nimport { BVScrollspy } from './helpers/bv-scrollspy.class'; // Key we use to store our instance\n\nvar BV_SCROLLSPY = '__BV_Scrollspy__'; // Pre-compiled regular expressions\n\nvar onlyDigitsRE = /^\\d+$/;\nvar offsetRE = /^(auto|position|offset)$/; // Build a Scrollspy config based on bindings (if any)\n// Arguments and modifiers take precedence over passed value config object\n\n/* istanbul ignore next: not easy to test */\n\nvar parseBindings = function parseBindings(bindings) /* istanbul ignore next: not easy to test */\n{\n  var config = {}; // If argument, assume element ID\n\n  if (bindings.arg) {\n    // Element ID specified as arg\n    // We must prepend '#' to become a CSS selector\n    config.element = \"#\".concat(bindings.arg);\n  } // Process modifiers\n\n  keys(bindings.modifiers).forEach(function (mod) {\n    if (onlyDigitsRE.test(mod)) {\n      // Offset value\n      config.offset = toInteger(mod, 0);\n    } else if (offsetRE.test(mod)) {\n      // Offset method\n      config.method = mod;\n    }\n  }); // Process value\n\n  if (isString(bindings.value)) {\n    // Value is a CSS ID or selector\n    config.element = bindings.value;\n  } else if (isNumber(bindings.value)) {\n    // Value is offset\n    config.offset = mathRound(bindings.value);\n  } else if (isObject(bindings.value)) {\n    // Value is config object\n    // Filter the object based on our supported config options\n    keys(bindings.value).filter(function (k) {\n      return !!BVScrollspy.DefaultType[k];\n    }).forEach(function (k) {\n      config[k] = bindings.value[k];\n    });\n  }\n  return config;\n}; // Add or update Scrollspy on our element\n\nvar applyScrollspy = function applyScrollspy(el, bindings, vnode) /* istanbul ignore next: not easy to test */\n{\n  if (!IS_BROWSER) {\n    /* istanbul ignore next */\n    return;\n  }\n  var config = parseBindings(bindings);\n  if (el[BV_SCROLLSPY]) {\n    el[BV_SCROLLSPY].updateConfig(config, getEventRoot(getInstanceFromDirective(vnode, bindings)));\n  } else {\n    el[BV_SCROLLSPY] = new BVScrollspy(el, config, getEventRoot(getInstanceFromDirective(vnode, bindings)));\n  }\n}; // Remove Scrollspy on our element\n\n/* istanbul ignore next: not easy to test */\n\nvar removeScrollspy = function removeScrollspy(el) /* istanbul ignore next: not easy to test */\n{\n  if (el[BV_SCROLLSPY]) {\n    el[BV_SCROLLSPY].dispose();\n    el[BV_SCROLLSPY] = null;\n    delete el[BV_SCROLLSPY];\n  }\n};\n/*\n * Export our directive\n */\n\nexport var VBScrollspy = {\n  /* istanbul ignore next: not easy to test */\n  bind: function bind(el, bindings, vnode) {\n    applyScrollspy(el, bindings, vnode);\n  },\n  /* istanbul ignore next: not easy to test */\n  inserted: function inserted(el, bindings, vnode) {\n    applyScrollspy(el, bindings, vnode);\n  },\n  /* istanbul ignore next: not easy to test */\n  update: function update(el, bindings, vnode) {\n    if (bindings.value !== bindings.oldValue) {\n      applyScrollspy(el, bindings, vnode);\n    }\n  },\n  /* istanbul ignore next: not easy to test */\n  componentUpdated: function componentUpdated(el, bindings, vnode) {\n    if (bindings.value !== bindings.oldValue) {\n      applyScrollspy(el, bindings, vnode);\n    }\n  },\n  /* istanbul ignore next: not easy to test */\n  unbind: function unbind(el) {\n    removeScrollspy(el);\n  }\n};","map":{"version":3,"names":["IS_BROWSER","isNumber","isObject","isString","mathRound","toInteger","keys","getEventRoot","getInstanceFromDirective","BVScrollspy","BV_SCROLLSPY","onlyDigitsRE","offsetRE","parseBindings","bindings","config","arg","element","concat","modifiers","forEach","mod","test","offset","method","value","filter","k","DefaultType","applyScrollspy","el","vnode","updateConfig","removeScrollspy","dispose","VBScrollspy","bind","inserted","update","oldValue","componentUpdated","unbind"],"sources":["E:/flask_learn/my_project/node_modules/bootstrap-vue/esm/directives/scrollspy/scrollspy.js"],"sourcesContent":["import { IS_BROWSER } from '../../constants/env';\nimport { isNumber, isObject, isString } from '../../utils/inspect';\nimport { mathRound } from '../../utils/math';\nimport { toInteger } from '../../utils/number';\nimport { keys } from '../../utils/object';\nimport { getEventRoot } from '../../utils/get-event-root';\nimport { getInstanceFromDirective } from '../../utils/get-instance-from-directive';\nimport { BVScrollspy } from './helpers/bv-scrollspy.class'; // Key we use to store our instance\n\nvar BV_SCROLLSPY = '__BV_Scrollspy__'; // Pre-compiled regular expressions\n\nvar onlyDigitsRE = /^\\d+$/;\nvar offsetRE = /^(auto|position|offset)$/; // Build a Scrollspy config based on bindings (if any)\n// Arguments and modifiers take precedence over passed value config object\n\n/* istanbul ignore next: not easy to test */\n\nvar parseBindings = function parseBindings(bindings)\n/* istanbul ignore next: not easy to test */\n{\n  var config = {}; // If argument, assume element ID\n\n  if (bindings.arg) {\n    // Element ID specified as arg\n    // We must prepend '#' to become a CSS selector\n    config.element = \"#\".concat(bindings.arg);\n  } // Process modifiers\n\n\n  keys(bindings.modifiers).forEach(function (mod) {\n    if (onlyDigitsRE.test(mod)) {\n      // Offset value\n      config.offset = toInteger(mod, 0);\n    } else if (offsetRE.test(mod)) {\n      // Offset method\n      config.method = mod;\n    }\n  }); // Process value\n\n  if (isString(bindings.value)) {\n    // Value is a CSS ID or selector\n    config.element = bindings.value;\n  } else if (isNumber(bindings.value)) {\n    // Value is offset\n    config.offset = mathRound(bindings.value);\n  } else if (isObject(bindings.value)) {\n    // Value is config object\n    // Filter the object based on our supported config options\n    keys(bindings.value).filter(function (k) {\n      return !!BVScrollspy.DefaultType[k];\n    }).forEach(function (k) {\n      config[k] = bindings.value[k];\n    });\n  }\n\n  return config;\n}; // Add or update Scrollspy on our element\n\n\nvar applyScrollspy = function applyScrollspy(el, bindings, vnode)\n/* istanbul ignore next: not easy to test */\n{\n  if (!IS_BROWSER) {\n    /* istanbul ignore next */\n    return;\n  }\n\n  var config = parseBindings(bindings);\n\n  if (el[BV_SCROLLSPY]) {\n    el[BV_SCROLLSPY].updateConfig(config, getEventRoot(getInstanceFromDirective(vnode, bindings)));\n  } else {\n    el[BV_SCROLLSPY] = new BVScrollspy(el, config, getEventRoot(getInstanceFromDirective(vnode, bindings)));\n  }\n}; // Remove Scrollspy on our element\n\n/* istanbul ignore next: not easy to test */\n\n\nvar removeScrollspy = function removeScrollspy(el)\n/* istanbul ignore next: not easy to test */\n{\n  if (el[BV_SCROLLSPY]) {\n    el[BV_SCROLLSPY].dispose();\n    el[BV_SCROLLSPY] = null;\n    delete el[BV_SCROLLSPY];\n  }\n};\n/*\n * Export our directive\n */\n\n\nexport var VBScrollspy = {\n  /* istanbul ignore next: not easy to test */\n  bind: function bind(el, bindings, vnode) {\n    applyScrollspy(el, bindings, vnode);\n  },\n\n  /* istanbul ignore next: not easy to test */\n  inserted: function inserted(el, bindings, vnode) {\n    applyScrollspy(el, bindings, vnode);\n  },\n\n  /* istanbul ignore next: not easy to test */\n  update: function update(el, bindings, vnode) {\n    if (bindings.value !== bindings.oldValue) {\n      applyScrollspy(el, bindings, vnode);\n    }\n  },\n\n  /* istanbul ignore next: not easy to test */\n  componentUpdated: function componentUpdated(el, bindings, vnode) {\n    if (bindings.value !== bindings.oldValue) {\n      applyScrollspy(el, bindings, vnode);\n    }\n  },\n\n  /* istanbul ignore next: not easy to test */\n  unbind: function unbind(el) {\n    removeScrollspy(el);\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}