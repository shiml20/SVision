{"ast":null,"code":"import { extend } from '../../../vue';\nimport { NAME_TABLE } from '../../../constants/components';\nimport { EVENT_NAME_REFRESH, EVENT_NAME_REFRESHED } from '../../../constants/events';\nimport { PROP_TYPE_ARRAY_FUNCTION, PROP_TYPE_BOOLEAN, PROP_TYPE_STRING } from '../../../constants/props';\nimport { getRootActionEventName, getRootEventName } from '../../../utils/events';\nimport { isArray, isFunction, isPromise } from '../../../utils/inspect';\nimport { looseEqual } from '../../../utils/loose-equal';\nimport { clone } from '../../../utils/object';\nimport { makeProp } from '../../../utils/props';\nimport { safeVueInstance } from '../../../utils/safe-vue-instance';\nimport { warn } from '../../../utils/warn';\nimport { listenOnRootMixin } from '../../../mixins/listen-on-root'; // --- Constants ---\n\nvar ROOT_EVENT_NAME_REFRESHED = getRootEventName(NAME_TABLE, EVENT_NAME_REFRESHED);\nvar ROOT_ACTION_EVENT_NAME_REFRESH = getRootActionEventName(NAME_TABLE, EVENT_NAME_REFRESH); // --- Props ---\n\nexport var props = {\n  // Passed to the context object\n  // Not used by `<b-table>` directly\n  apiUrl: makeProp(PROP_TYPE_STRING),\n  // Adds in 'Function' support\n  items: makeProp(PROP_TYPE_ARRAY_FUNCTION, []),\n  noProviderFiltering: makeProp(PROP_TYPE_BOOLEAN, false),\n  noProviderPaging: makeProp(PROP_TYPE_BOOLEAN, false),\n  noProviderSorting: makeProp(PROP_TYPE_BOOLEAN, false)\n}; // --- Mixin ---\n// @vue/component\n\nexport var providerMixin = extend({\n  mixins: [listenOnRootMixin],\n  props: props,\n  computed: {\n    hasProvider: function hasProvider() {\n      return isFunction(this.items);\n    },\n    providerTriggerContext: function providerTriggerContext() {\n      // Used to trigger the provider function via a watcher. Only the fields that\n      // are needed for triggering a provider update are included. Note that the\n      // regular this.context is sent to the provider during fetches though, as they\n      // may need all the prop info.\n      var ctx = {\n        apiUrl: this.apiUrl,\n        filter: null,\n        sortBy: null,\n        sortDesc: null,\n        perPage: null,\n        currentPage: null\n      };\n      if (!this.noProviderFiltering) {\n        // Either a string, or could be an object or array.\n        ctx.filter = this.localFilter;\n      }\n      if (!this.noProviderSorting) {\n        ctx.sortBy = this.localSortBy;\n        ctx.sortDesc = this.localSortDesc;\n      }\n      if (!this.noProviderPaging) {\n        ctx.perPage = this.perPage;\n        ctx.currentPage = this.currentPage;\n      }\n      return clone(ctx);\n    }\n  },\n  watch: {\n    // Provider update triggering\n    items: function items(newValue) {\n      // If a new provider has been specified, trigger an update\n      if (this.hasProvider || isFunction(newValue)) {\n        this.$nextTick(this._providerUpdate);\n      }\n    },\n    providerTriggerContext: function providerTriggerContext(newValue, oldValue) {\n      // Trigger the provider to update as the relevant context values have changed.\n      if (!looseEqual(newValue, oldValue)) {\n        this.$nextTick(this._providerUpdate);\n      }\n    }\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    // Call the items provider if necessary\n    if (this.hasProvider && (!this.localItems || this.localItems.length === 0)) {\n      // Fetch on mount if localItems is empty\n      this._providerUpdate();\n    } // Listen for global messages to tell us to force refresh the table\n\n    this.listenOnRoot(ROOT_ACTION_EVENT_NAME_REFRESH, function (id) {\n      if (id === _this.id || id === _this) {\n        _this.refresh();\n      }\n    });\n  },\n  methods: {\n    refresh: function refresh() {\n      var _safeVueInstance = safeVueInstance(this),\n        items = _safeVueInstance.items,\n        refresh = _safeVueInstance.refresh,\n        computedBusy = _safeVueInstance.computedBusy; // Public Method: Force a refresh of the provider function\n\n      this.$off(EVENT_NAME_REFRESHED, refresh);\n      if (computedBusy) {\n        // Can't force an update when forced busy by user (busy prop === true)\n        if (this.localBusy && this.hasProvider) {\n          // But if provider running (localBusy), re-schedule refresh once `refreshed` emitted\n          this.$on(EVENT_NAME_REFRESHED, refresh);\n        }\n      } else {\n        this.clearSelected();\n        if (this.hasProvider) {\n          this.$nextTick(this._providerUpdate);\n        } else {\n          /* istanbul ignore next */\n          this.localItems = isArray(items) ? items.slice() : [];\n        }\n      }\n    },\n    // Provider related methods\n    _providerSetLocal: function _providerSetLocal(items) {\n      this.localItems = isArray(items) ? items.slice() : [];\n      this.localBusy = false;\n      this.$emit(EVENT_NAME_REFRESHED); // New root emit\n\n      if (this.id) {\n        this.emitOnRoot(ROOT_EVENT_NAME_REFRESHED, this.id);\n      }\n    },\n    _providerUpdate: function _providerUpdate() {\n      var _this2 = this;\n\n      // Refresh the provider function items.\n      if (!this.hasProvider) {\n        // Do nothing if no provider\n        return;\n      } // If table is busy, wait until refreshed before calling again\n\n      if (safeVueInstance(this).computedBusy) {\n        // Schedule a new refresh once `refreshed` is emitted\n        this.$nextTick(this.refresh);\n        return;\n      } // Set internal busy state\n\n      this.localBusy = true; // Call provider function with context and optional callback after DOM is fully updated\n\n      this.$nextTick(function () {\n        try {\n          // Call provider function passing it the context and optional callback\n          var data = _this2.items(_this2.context, _this2._providerSetLocal);\n          if (isPromise(data)) {\n            // Provider returned Promise\n            data.then(function (items) {\n              // Provider resolved with items\n              _this2._providerSetLocal(items);\n            });\n          } else if (isArray(data)) {\n            // Provider returned Array data\n            _this2._providerSetLocal(data);\n          } else {\n            /* istanbul ignore if */\n            if (_this2.items.length !== 2) {\n              // Check number of arguments provider function requested\n              // Provider not using callback (didn't request second argument), so we clear\n              // busy state as most likely there was an error in the provider function\n\n              /* istanbul ignore next */\n              warn(\"Provider function didn't request callback and did not return a promise or data.\", NAME_TABLE);\n              _this2.localBusy = false;\n            }\n          }\n        } catch (e) /* istanbul ignore next */\n        {\n          // Provider function borked on us, so we spew out a warning\n          // and clear the busy state\n          warn(\"Provider function error [\".concat(e.name, \"] \").concat(e.message, \".\"), NAME_TABLE);\n          _this2.localBusy = false;\n          _this2.$off(EVENT_NAME_REFRESHED, _this2.refresh);\n        }\n      });\n    }\n  }\n});","map":{"version":3,"names":["extend","NAME_TABLE","EVENT_NAME_REFRESH","EVENT_NAME_REFRESHED","PROP_TYPE_ARRAY_FUNCTION","PROP_TYPE_BOOLEAN","PROP_TYPE_STRING","getRootActionEventName","getRootEventName","isArray","isFunction","isPromise","looseEqual","clone","makeProp","safeVueInstance","warn","listenOnRootMixin","ROOT_EVENT_NAME_REFRESHED","ROOT_ACTION_EVENT_NAME_REFRESH","props","apiUrl","items","noProviderFiltering","noProviderPaging","noProviderSorting","providerMixin","mixins","computed","hasProvider","providerTriggerContext","ctx","filter","sortBy","sortDesc","perPage","currentPage","localFilter","localSortBy","localSortDesc","watch","newValue","$nextTick","_providerUpdate","oldValue","mounted","_this","localItems","length","listenOnRoot","id","refresh","methods","_safeVueInstance","computedBusy","$off","localBusy","$on","clearSelected","slice","_providerSetLocal","$emit","emitOnRoot","_this2","data","context","then","e","concat","name","message"],"sources":["E:/flask_learn/my_project/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-provider.js"],"sourcesContent":["import { extend } from '../../../vue';\nimport { NAME_TABLE } from '../../../constants/components';\nimport { EVENT_NAME_REFRESH, EVENT_NAME_REFRESHED } from '../../../constants/events';\nimport { PROP_TYPE_ARRAY_FUNCTION, PROP_TYPE_BOOLEAN, PROP_TYPE_STRING } from '../../../constants/props';\nimport { getRootActionEventName, getRootEventName } from '../../../utils/events';\nimport { isArray, isFunction, isPromise } from '../../../utils/inspect';\nimport { looseEqual } from '../../../utils/loose-equal';\nimport { clone } from '../../../utils/object';\nimport { makeProp } from '../../../utils/props';\nimport { safeVueInstance } from '../../../utils/safe-vue-instance';\nimport { warn } from '../../../utils/warn';\nimport { listenOnRootMixin } from '../../../mixins/listen-on-root'; // --- Constants ---\n\nvar ROOT_EVENT_NAME_REFRESHED = getRootEventName(NAME_TABLE, EVENT_NAME_REFRESHED);\nvar ROOT_ACTION_EVENT_NAME_REFRESH = getRootActionEventName(NAME_TABLE, EVENT_NAME_REFRESH); // --- Props ---\n\nexport var props = {\n  // Passed to the context object\n  // Not used by `<b-table>` directly\n  apiUrl: makeProp(PROP_TYPE_STRING),\n  // Adds in 'Function' support\n  items: makeProp(PROP_TYPE_ARRAY_FUNCTION, []),\n  noProviderFiltering: makeProp(PROP_TYPE_BOOLEAN, false),\n  noProviderPaging: makeProp(PROP_TYPE_BOOLEAN, false),\n  noProviderSorting: makeProp(PROP_TYPE_BOOLEAN, false)\n}; // --- Mixin ---\n// @vue/component\n\nexport var providerMixin = extend({\n  mixins: [listenOnRootMixin],\n  props: props,\n  computed: {\n    hasProvider: function hasProvider() {\n      return isFunction(this.items);\n    },\n    providerTriggerContext: function providerTriggerContext() {\n      // Used to trigger the provider function via a watcher. Only the fields that\n      // are needed for triggering a provider update are included. Note that the\n      // regular this.context is sent to the provider during fetches though, as they\n      // may need all the prop info.\n      var ctx = {\n        apiUrl: this.apiUrl,\n        filter: null,\n        sortBy: null,\n        sortDesc: null,\n        perPage: null,\n        currentPage: null\n      };\n\n      if (!this.noProviderFiltering) {\n        // Either a string, or could be an object or array.\n        ctx.filter = this.localFilter;\n      }\n\n      if (!this.noProviderSorting) {\n        ctx.sortBy = this.localSortBy;\n        ctx.sortDesc = this.localSortDesc;\n      }\n\n      if (!this.noProviderPaging) {\n        ctx.perPage = this.perPage;\n        ctx.currentPage = this.currentPage;\n      }\n\n      return clone(ctx);\n    }\n  },\n  watch: {\n    // Provider update triggering\n    items: function items(newValue) {\n      // If a new provider has been specified, trigger an update\n      if (this.hasProvider || isFunction(newValue)) {\n        this.$nextTick(this._providerUpdate);\n      }\n    },\n    providerTriggerContext: function providerTriggerContext(newValue, oldValue) {\n      // Trigger the provider to update as the relevant context values have changed.\n      if (!looseEqual(newValue, oldValue)) {\n        this.$nextTick(this._providerUpdate);\n      }\n    }\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    // Call the items provider if necessary\n    if (this.hasProvider && (!this.localItems || this.localItems.length === 0)) {\n      // Fetch on mount if localItems is empty\n      this._providerUpdate();\n    } // Listen for global messages to tell us to force refresh the table\n\n\n    this.listenOnRoot(ROOT_ACTION_EVENT_NAME_REFRESH, function (id) {\n      if (id === _this.id || id === _this) {\n        _this.refresh();\n      }\n    });\n  },\n  methods: {\n    refresh: function refresh() {\n      var _safeVueInstance = safeVueInstance(this),\n          items = _safeVueInstance.items,\n          refresh = _safeVueInstance.refresh,\n          computedBusy = _safeVueInstance.computedBusy; // Public Method: Force a refresh of the provider function\n\n\n      this.$off(EVENT_NAME_REFRESHED, refresh);\n\n      if (computedBusy) {\n        // Can't force an update when forced busy by user (busy prop === true)\n        if (this.localBusy && this.hasProvider) {\n          // But if provider running (localBusy), re-schedule refresh once `refreshed` emitted\n          this.$on(EVENT_NAME_REFRESHED, refresh);\n        }\n      } else {\n        this.clearSelected();\n\n        if (this.hasProvider) {\n          this.$nextTick(this._providerUpdate);\n        } else {\n          /* istanbul ignore next */\n          this.localItems = isArray(items) ? items.slice() : [];\n        }\n      }\n    },\n    // Provider related methods\n    _providerSetLocal: function _providerSetLocal(items) {\n      this.localItems = isArray(items) ? items.slice() : [];\n      this.localBusy = false;\n      this.$emit(EVENT_NAME_REFRESHED); // New root emit\n\n      if (this.id) {\n        this.emitOnRoot(ROOT_EVENT_NAME_REFRESHED, this.id);\n      }\n    },\n    _providerUpdate: function _providerUpdate() {\n      var _this2 = this;\n\n      // Refresh the provider function items.\n      if (!this.hasProvider) {\n        // Do nothing if no provider\n        return;\n      } // If table is busy, wait until refreshed before calling again\n\n\n      if (safeVueInstance(this).computedBusy) {\n        // Schedule a new refresh once `refreshed` is emitted\n        this.$nextTick(this.refresh);\n        return;\n      } // Set internal busy state\n\n\n      this.localBusy = true; // Call provider function with context and optional callback after DOM is fully updated\n\n      this.$nextTick(function () {\n        try {\n          // Call provider function passing it the context and optional callback\n          var data = _this2.items(_this2.context, _this2._providerSetLocal);\n\n          if (isPromise(data)) {\n            // Provider returned Promise\n            data.then(function (items) {\n              // Provider resolved with items\n              _this2._providerSetLocal(items);\n            });\n          } else if (isArray(data)) {\n            // Provider returned Array data\n            _this2._providerSetLocal(data);\n          } else {\n            /* istanbul ignore if */\n            if (_this2.items.length !== 2) {\n              // Check number of arguments provider function requested\n              // Provider not using callback (didn't request second argument), so we clear\n              // busy state as most likely there was an error in the provider function\n\n              /* istanbul ignore next */\n              warn(\"Provider function didn't request callback and did not return a promise or data.\", NAME_TABLE);\n              _this2.localBusy = false;\n            }\n          }\n        } catch (e)\n        /* istanbul ignore next */\n        {\n          // Provider function borked on us, so we spew out a warning\n          // and clear the busy state\n          warn(\"Provider function error [\".concat(e.name, \"] \").concat(e.message, \".\"), NAME_TABLE);\n          _this2.localBusy = false;\n\n          _this2.$off(EVENT_NAME_REFRESHED, _this2.refresh);\n        }\n      });\n    }\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}