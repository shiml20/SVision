{"ast":null,"code":"var e = function () {\n    return (e = Object.assign || function (e) {\n      for (var t, r = 1, s = arguments.length; r < s; r++) for (var a in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);\n      return e;\n    }).apply(this, arguments);\n  },\n  t = {\n    kebab: /-(\\w)/g,\n    styleProp: /:(.*)/,\n    styleList: /;(?![^(]*\\))/g\n  };\nfunction r(e, t) {\n  return t ? t.toUpperCase() : \"\";\n}\nfunction s(e) {\n  for (var s, a = {}, c = 0, o = e.split(t.styleList); c < o.length; c++) {\n    var n = o[c].split(t.styleProp),\n      i = n[0],\n      l = n[1];\n    (i = i.trim()) && (\"string\" == typeof l && (l = l.trim()), a[(s = i, s.replace(t.kebab, r))] = l);\n  }\n  return a;\n}\nfunction a() {\n  for (var t, r, a = {}, c = arguments.length; c--;) for (var o = 0, n = Object.keys(arguments[c]); o < n.length; o++) switch (t = n[o]) {\n    case \"class\":\n    case \"style\":\n    case \"directives\":\n      if (Array.isArray(a[t]) || (a[t] = []), \"style\" === t) {\n        var i = void 0;\n        i = Array.isArray(arguments[c].style) ? arguments[c].style : [arguments[c].style];\n        for (var l = 0; l < i.length; l++) {\n          var y = i[l];\n          \"string\" == typeof y && (i[l] = s(y));\n        }\n        arguments[c].style = i;\n      }\n      a[t] = a[t].concat(arguments[c][t]);\n      break;\n    case \"staticClass\":\n      if (!arguments[c][t]) break;\n      void 0 === a[t] && (a[t] = \"\"), a[t] && (a[t] += \" \"), a[t] += arguments[c][t].trim();\n      break;\n    case \"on\":\n    case \"nativeOn\":\n      a[t] || (a[t] = {});\n      for (var p = 0, f = Object.keys(arguments[c][t] || {}); p < f.length; p++) r = f[p], a[t][r] ? a[t][r] = [].concat(a[t][r], arguments[c][t][r]) : a[t][r] = arguments[c][t][r];\n      break;\n    case \"attrs\":\n    case \"props\":\n    case \"domProps\":\n    case \"scopedSlots\":\n    case \"staticStyle\":\n    case \"hook\":\n    case \"transition\":\n      a[t] || (a[t] = {}), a[t] = e({}, arguments[c][t], a[t]);\n      break;\n    case \"slot\":\n    case \"key\":\n    case \"ref\":\n    case \"tag\":\n    case \"show\":\n    case \"keepAlive\":\n    default:\n      a[t] || (a[t] = arguments[c][t]);\n  }\n  return a;\n}\nexport { a as mergeData };","map":{"version":3,"mappings":";;;;;;EAEMA,IAAU;IACdC,OAAO;IACPC,WAAW;IACZC,WAAW;EAAA;AAGZ,SAASC,EAAaC,GAAiBC;EACrC,OAAOA,IAAQA,EAAMC,gBAAgB;AAAA;AAOvC,SAASC,EAAWC;EAGlB,KAFA,IALiBC,GAKbC,IAAgC,WAEtBC,MAAMC,MAAMb,EAAQG,YAApBW,mBAAgC;IAAzC,IACCC;MAACC;MAAKC;IAAAA,CACVD,IAAMA,EAAIE,YAKS,mBAARD,MACTA,IAAMA,EAAIC,SAEZP,GAjBeD,IAiBIM,GAhBdN,EAAIS,QAAQnB,EAAQC,OAAOG,OAgBLa;EAAAA;EAG7B,OAAON;AAAAA;AAST,SAASS;EAOP,KANA,IAEIC,GACAC,GAHAC,IAA+C,IAC/CC,IAAYC,UAAUC,QAKnBF,MAGL,KAAa,sBAAOG,KAAKF,UAAUD,KAAtBV,mBACX,QADGO;IAGD,KAAK;IACL,KAAK;IACL,KAAK;MAKH,IAJKO,MAAMC,QAAQN,EAAYF,QAC7BE,EAAYF,KAAQ,KAGT,YAATA,GAAkB;QACpB,IAAIZ;QAEFA,IADEmB,MAAMC,QAAQJ,UAAUD,GAAGf,SACrBgB,UAAUD,GAAGf,QAEb,CAACgB,UAAUD,GAAGf;QAExB,KAAK,IAAIqB,IAAI,GAAGA,IAAIrB,EAAMiB,QAAQI,KAAK;UACrC,IAAIC,IAAItB,EAAMqB;UACG,mBAANC,MACTtB,EAAMqB,KAAKtB,EAAWuB;QAAAA;QAG1BN,UAAUD,GAAGf,QAAQA;MAAAA;MAKvBc,EAAYF,KAAQE,EAAYF,GAAMW,OAAOP,UAAUD,GAAGH;MAC1D;IAEF,KAAK;MACH,KAAKI,UAAUD,GAAGH,IAChB;MAAA,KAEwBY,MAAtBV,EAAYF,OACdE,EAAYF,KAAQ,KAElBE,EAAYF,OAEdE,EAAYF,MAAS,MAEvBE,EAAYF,MAASI,UAAUD,GAAGH,GAAMH;MACxC;IAMF,KAAK;IACL,KAAK;MACEK,EAAYF,OACfE,EAAYF,KAAQ;MAEtB,KAAc,sBAAOM,KAAKF,UAAUD,GAAGH,MAAS,KAAlCN,mBAATO,UAECC,EAAYF,GAAMC,KAEpBC,EAAYF,GAAMC,KAAS,GAAGU,OAC5BT,EAAYF,GAAMC,IAClBG,UAAUD,GAAGH,GAAMC,MAIrBC,EAAYF,GAAMC,KAASG,UAAUD,GAAGH,GAAMC;MAGlD;IAEF,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;MACEC,EAAYF,OACfE,EAAYF,KAAQ,KAEtBE,EAAYF,WAAaI,UAAUD,GAAGH,IAAUE,EAAYF;MAC5D;IAEF,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL;MACOE,EAAYF,OACfE,EAAYF,KAAQI,UAAUD,GAAGH;EAAAA;EAM3C,OAAOE;AAAAA;AAAAA","names":["pattern","kebab","styleProp","styleList","camelReplace","_substr","match","toUpperCase","parseStyle","style","str","styleMap","_a","split","_i","_b","key","val","trim","replace","mergeData","prop","event","mergeTarget","i","arguments","length","keys","Array","isArray","j","s","concat","undefined"],"sources":["../src/index.ts"],"sourcesContent":["import { VNodeData } from \"vue\";\n\nconst pattern = {\n  kebab: /-(\\w)/g,\n  styleProp: /:(.*)/,\n\tstyleList: /;(?![^(]*\\))/g,\n} as const;\n\nfunction camelReplace(_substr: string, match: string) {\n  return match ? match.toUpperCase() : \"\";\n}\n\nfunction camelCase(str: string) {\n  return str.replace(pattern.kebab, camelReplace);\n}\n\nfunction parseStyle(style: string) {\n  let styleMap: Record<string, any> = {};\n\n  for (let s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp);\n    key = key.trim();\n    if (!key) {\n      continue;\n    }\n    // May be undefined if the `key: value` pair is incomplete.\n    if (typeof val === \"string\") {\n      val = val.trim();\n    }\n    styleMap[camelCase(key)] = val;\n  }\n\n  return styleMap;\n}\n\n/**\n * Intelligently merges data for createElement.\n * Merges arguments left to right, preferring the right argument.\n * Returns new VNodeData object.\n */\nfunction mergeData(...vNodeData: VNodeData[]): VNodeData;\nfunction mergeData(): VNodeData {\n  let mergeTarget: VNodeData & Record<string, any> = {};\n  let i: number = arguments.length;\n  let prop: string;\n  let event: string;\n\n  // Allow for variadic argument length.\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case \"class\":\n        case \"style\":\n        case \"directives\":\n          if (!Array.isArray(mergeTarget[prop])) {\n            mergeTarget[prop] = [];\n          }\n\n          if (prop === \"style\") {\n            let style: any[];\n            if (Array.isArray(arguments[i].style)) {\n              style = arguments[i].style;\n            } else {\n              style = [arguments[i].style];\n            }\n            for (let j = 0; j < style.length; j++) {\n              let s = style[j];\n              if (typeof s === \"string\") {\n                style[j] = parseStyle(s);\n              }\n            }\n            arguments[i].style = style;\n          }\n\n          // Repackaging in an array allows Vue runtime\n          // to merge class/style bindings regardless of type.\n          mergeTarget[prop] = mergeTarget[prop].concat(arguments[i][prop]);\n          break;\n        // Space delimited string concatenation strategy\n        case \"staticClass\":\n          if (!arguments[i][prop]) {\n            break;\n          }\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = \"\";\n          }\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += \" \";\n          }\n          mergeTarget[prop] += arguments[i][prop].trim();\n          break;\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n        case \"on\":\n        case \"nativeOn\":\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n          for (event of Object.keys(arguments[i][prop] || {})) {\n            // Concat function to array of functions if callback present.\n            if (mergeTarget[prop][event]) {\n              // Insert current iteration data in beginning of merged array.\n              mergeTarget[prop][event] = [].concat(\n                mergeTarget[prop][event],\n                arguments[i][prop][event]\n              );\n            } else {\n              // Straight assign.\n              mergeTarget[prop][event] = arguments[i][prop][event];\n            }\n          }\n          break;\n        // Object merge strategy\n        case \"attrs\":\n        case \"props\":\n        case \"domProps\":\n        case \"scopedSlots\":\n        case \"staticStyle\":\n        case \"hook\":\n        case \"transition\":\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n          mergeTarget[prop] = { ...arguments[i][prop], ...mergeTarget[prop] };\n          break;\n        // Reassignment strategy (no merge)\n        case \"slot\":\n        case \"key\":\n        case \"ref\":\n        case \"tag\":\n        case \"show\":\n        case \"keepAlive\":\n        default:\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop];\n          }\n      }\n    }\n  }\n\n  return mergeTarget;\n}\n\nexport { mergeData };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}