{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { identity } from '../../../utils/identity';\nimport { isArray, isFunction, isObject, isString } from '../../../utils/inspect';\nimport { clone, keys } from '../../../utils/object';\nimport { startCase } from '../../../utils/string';\nimport { IGNORED_FIELD_KEYS } from './constants'; // Private function to massage field entry into common object format\n\nvar processField = function processField(key, value) {\n  var field = null;\n  if (isString(value)) {\n    // Label shortcut\n    field = {\n      key: key,\n      label: value\n    };\n  } else if (isFunction(value)) {\n    // Formatter shortcut\n    field = {\n      key: key,\n      formatter: value\n    };\n  } else if (isObject(value)) {\n    field = clone(value);\n    field.key = field.key || key;\n  } else if (value !== false) {\n    // Fallback to just key\n\n    /* istanbul ignore next */\n    field = {\n      key: key\n    };\n  }\n  return field;\n}; // We normalize fields into an array of objects\n// [ { key:..., label:..., ...}, {...}, ..., {..}]\n\nexport var normalizeFields = function normalizeFields(origFields, items) {\n  var fields = [];\n  if (isArray(origFields)) {\n    // Normalize array Form\n    origFields.filter(identity).forEach(function (f) {\n      if (isString(f)) {\n        fields.push({\n          key: f,\n          label: startCase(f)\n        });\n      } else if (isObject(f) && f.key && isString(f.key)) {\n        // Full object definition. We use assign so that we don't mutate the original\n        fields.push(clone(f));\n      } else if (isObject(f) && keys(f).length === 1) {\n        // Shortcut object (i.e. { 'foo_bar': 'This is Foo Bar' }\n        var key = keys(f)[0];\n        var field = processField(key, f[key]);\n        if (field) {\n          fields.push(field);\n        }\n      }\n    });\n  } // If no field provided, take a sample from first record (if exits)\n\n  if (fields.length === 0 && isArray(items) && items.length > 0) {\n    var sample = items[0];\n    keys(sample).forEach(function (k) {\n      if (!IGNORED_FIELD_KEYS[k]) {\n        fields.push({\n          key: k,\n          label: startCase(k)\n        });\n      }\n    });\n  } // Ensure we have a unique array of fields and that they have String labels\n\n  var memo = {};\n  return fields.filter(function (f) {\n    if (!memo[f.key]) {\n      memo[f.key] = true;\n      f.label = isString(f.label) ? f.label : startCase(f.key);\n      return true;\n    }\n    return false;\n  });\n};","map":{"version":3,"names":["identity","isArray","isFunction","isObject","isString","clone","keys","startCase","IGNORED_FIELD_KEYS","processField","key","value","field","label","formatter","normalizeFields","origFields","items","fields","filter","forEach","f","push","length","sample","k","memo"],"sources":["E:/flask_learn/my_project/node_modules/bootstrap-vue/esm/components/table/helpers/normalize-fields.js"],"sourcesContent":["import { identity } from '../../../utils/identity';\nimport { isArray, isFunction, isObject, isString } from '../../../utils/inspect';\nimport { clone, keys } from '../../../utils/object';\nimport { startCase } from '../../../utils/string';\nimport { IGNORED_FIELD_KEYS } from './constants'; // Private function to massage field entry into common object format\n\nvar processField = function processField(key, value) {\n  var field = null;\n\n  if (isString(value)) {\n    // Label shortcut\n    field = {\n      key: key,\n      label: value\n    };\n  } else if (isFunction(value)) {\n    // Formatter shortcut\n    field = {\n      key: key,\n      formatter: value\n    };\n  } else if (isObject(value)) {\n    field = clone(value);\n    field.key = field.key || key;\n  } else if (value !== false) {\n    // Fallback to just key\n\n    /* istanbul ignore next */\n    field = {\n      key: key\n    };\n  }\n\n  return field;\n}; // We normalize fields into an array of objects\n// [ { key:..., label:..., ...}, {...}, ..., {..}]\n\n\nexport var normalizeFields = function normalizeFields(origFields, items) {\n  var fields = [];\n\n  if (isArray(origFields)) {\n    // Normalize array Form\n    origFields.filter(identity).forEach(function (f) {\n      if (isString(f)) {\n        fields.push({\n          key: f,\n          label: startCase(f)\n        });\n      } else if (isObject(f) && f.key && isString(f.key)) {\n        // Full object definition. We use assign so that we don't mutate the original\n        fields.push(clone(f));\n      } else if (isObject(f) && keys(f).length === 1) {\n        // Shortcut object (i.e. { 'foo_bar': 'This is Foo Bar' }\n        var key = keys(f)[0];\n        var field = processField(key, f[key]);\n\n        if (field) {\n          fields.push(field);\n        }\n      }\n    });\n  } // If no field provided, take a sample from first record (if exits)\n\n\n  if (fields.length === 0 && isArray(items) && items.length > 0) {\n    var sample = items[0];\n    keys(sample).forEach(function (k) {\n      if (!IGNORED_FIELD_KEYS[k]) {\n        fields.push({\n          key: k,\n          label: startCase(k)\n        });\n      }\n    });\n  } // Ensure we have a unique array of fields and that they have String labels\n\n\n  var memo = {};\n  return fields.filter(function (f) {\n    if (!memo[f.key]) {\n      memo[f.key] = true;\n      f.label = isString(f.label) ? f.label : startCase(f.key);\n      return true;\n    }\n\n    return false;\n  });\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}