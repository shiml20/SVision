{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\n// v-b-visible\n// Private visibility check directive\n// Based on IntersectionObserver\n//\n// Usage:\n//  v-b-visibility.<margin>.<once>=\"<callback>\"\n//\n//  Value:\n//  <callback>: method to be called when visibility state changes, receives one arg:\n//     true:  element is visible\n//     false: element is not visible\n//     null:  IntersectionObserver not supported\n//\n//  Modifiers:\n//    <margin>: a positive decimal value of pixels away from viewport edge\n//              before being considered \"visible\". default is 0\n//    <once>:   keyword 'once', meaning when the element becomes visible and\n//              callback is called observation/notification will stop.\n//\n// When used in a render function:\n// export default {\n//   directives: { 'b-visible': VBVisible },\n//   render(h) {\n//     h(\n//       'div',\n//       {\n//         directives: [\n//           { name: 'b-visible', value=this.callback, modifiers: { '123':true, 'once':true } }\n//         ]\n//       }\n//     )\n//   }\nimport { RX_DIGITS } from '../../constants/regex';\nimport { requestAF } from '../../utils/dom';\nimport { isFunction } from '../../utils/inspect';\nimport { looseEqual } from '../../utils/loose-equal';\nimport { clone, keys } from '../../utils/object';\nimport { nextTick } from '../../vue';\nvar OBSERVER_PROP_NAME = '__bv__visibility_observer';\nvar VisibilityObserver = /*#__PURE__*/function () {\n  function VisibilityObserver(el, options) {\n    _classCallCheck(this, VisibilityObserver);\n    this.el = el;\n    this.callback = options.callback;\n    this.margin = options.margin || 0;\n    this.once = options.once || false;\n    this.observer = null;\n    this.visible = undefined;\n    this.doneOnce = false; // Create the observer instance (if possible)\n\n    this.createObserver();\n  }\n  _createClass(VisibilityObserver, [{\n    key: \"createObserver\",\n    value: function createObserver() {\n      var _this = this;\n\n      // Remove any previous observer\n      if (this.observer) {\n        /* istanbul ignore next */\n        this.stop();\n      } // Should only be called once and `callback` prop should be a function\n\n      if (this.doneOnce || !isFunction(this.callback)) {\n        /* istanbul ignore next */\n        return;\n      } // Create the observer instance\n\n      try {\n        // Future: Possibly add in other modifiers for left/right/top/bottom\n        // offsets, root element reference, and thresholds\n        this.observer = new IntersectionObserver(this.handler.bind(this), {\n          // `null` = 'viewport'\n          root: null,\n          // Pixels away from view port to consider \"visible\"\n          rootMargin: this.margin,\n          // Intersection ratio of el and root (as a value from 0 to 1)\n          threshold: 0\n        });\n      } catch (_unused) {\n        // No IntersectionObserver support, so just stop trying to observe\n        this.doneOnce = true;\n        this.observer = undefined;\n        this.callback(null);\n        return;\n      } // Start observing in a `$nextTick()` (to allow DOM to complete rendering)\n\n      /* istanbul ignore next: IntersectionObserver not supported in JSDOM */\n\n      nextTick(function () {\n        requestAF(function () {\n          // Placed in an `if` just in case we were destroyed before\n          // this `requestAnimationFrame` runs\n          if (_this.observer) {\n            _this.observer.observe(_this.el);\n          }\n        });\n      });\n    }\n    /* istanbul ignore next */\n  }, {\n    key: \"handler\",\n    value: function handler(entries) {\n      var entry = entries ? entries[0] : {};\n      var isIntersecting = Boolean(entry.isIntersecting || entry.intersectionRatio > 0.0);\n      if (isIntersecting !== this.visible) {\n        this.visible = isIntersecting;\n        this.callback(isIntersecting);\n        if (this.once && this.visible) {\n          this.doneOnce = true;\n          this.stop();\n        }\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      /* istanbul ignore next */\n      this.observer && this.observer.disconnect();\n      this.observer = null;\n    }\n  }]);\n  return VisibilityObserver;\n}();\nvar destroy = function destroy(el) {\n  var observer = el[OBSERVER_PROP_NAME];\n  if (observer && observer.stop) {\n    observer.stop();\n  }\n  delete el[OBSERVER_PROP_NAME];\n};\nvar bind = function bind(el, _ref) {\n  var value = _ref.value,\n    modifiers = _ref.modifiers;\n  // `value` is the callback function\n  var options = {\n    margin: '0px',\n    once: false,\n    callback: value\n  }; // Parse modifiers\n\n  keys(modifiers).forEach(function (mod) {\n    /* istanbul ignore else: Until <b-img-lazy> is switched to use this directive */\n    if (RX_DIGITS.test(mod)) {\n      options.margin = \"\".concat(mod, \"px\");\n    } else if (mod.toLowerCase() === 'once') {\n      options.once = true;\n    }\n  }); // Destroy any previous observer\n\n  destroy(el); // Create new observer\n\n  el[OBSERVER_PROP_NAME] = new VisibilityObserver(el, options); // Store the current modifiers on the object (cloned)\n\n  el[OBSERVER_PROP_NAME]._prevModifiers = clone(modifiers);\n}; // When the directive options may have been updated (or element)\n\nvar componentUpdated = function componentUpdated(el, _ref2, vnode) {\n  var value = _ref2.value,\n    oldValue = _ref2.oldValue,\n    modifiers = _ref2.modifiers;\n  // Compare value/oldValue and modifiers to see if anything has changed\n  // and if so, destroy old observer and create new observer\n\n  /* istanbul ignore next */\n  modifiers = clone(modifiers);\n  /* istanbul ignore next */\n\n  if (el && (value !== oldValue || !el[OBSERVER_PROP_NAME] || !looseEqual(modifiers, el[OBSERVER_PROP_NAME]._prevModifiers))) {\n    // Re-bind on element\n    bind(el, {\n      value: value,\n      modifiers: modifiers\n    }, vnode);\n  }\n}; // When directive un-binds from element\n\nvar unbind = function unbind(el) {\n  // Remove the observer\n  destroy(el);\n}; // Export the directive\n\nexport var VBVisible = {\n  bind: bind,\n  componentUpdated: componentUpdated,\n  unbind: unbind\n};","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","RX_DIGITS","requestAF","isFunction","looseEqual","clone","keys","nextTick","OBSERVER_PROP_NAME","VisibilityObserver","el","options","callback","margin","once","observer","visible","undefined","doneOnce","createObserver","value","_this","stop","IntersectionObserver","handler","bind","root","rootMargin","threshold","_unused","observe","entries","entry","isIntersecting","Boolean","intersectionRatio","disconnect","destroy","_ref","modifiers","forEach","mod","test","concat","toLowerCase","_prevModifiers","componentUpdated","_ref2","vnode","oldValue","unbind","VBVisible"],"sources":["E:/flask_learn/my_project/node_modules/bootstrap-vue/esm/directives/visible/visible.js"],"sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n// v-b-visible\n// Private visibility check directive\n// Based on IntersectionObserver\n//\n// Usage:\n//  v-b-visibility.<margin>.<once>=\"<callback>\"\n//\n//  Value:\n//  <callback>: method to be called when visibility state changes, receives one arg:\n//     true:  element is visible\n//     false: element is not visible\n//     null:  IntersectionObserver not supported\n//\n//  Modifiers:\n//    <margin>: a positive decimal value of pixels away from viewport edge\n//              before being considered \"visible\". default is 0\n//    <once>:   keyword 'once', meaning when the element becomes visible and\n//              callback is called observation/notification will stop.\n//\n// When used in a render function:\n// export default {\n//   directives: { 'b-visible': VBVisible },\n//   render(h) {\n//     h(\n//       'div',\n//       {\n//         directives: [\n//           { name: 'b-visible', value=this.callback, modifiers: { '123':true, 'once':true } }\n//         ]\n//       }\n//     )\n//   }\nimport { RX_DIGITS } from '../../constants/regex';\nimport { requestAF } from '../../utils/dom';\nimport { isFunction } from '../../utils/inspect';\nimport { looseEqual } from '../../utils/loose-equal';\nimport { clone, keys } from '../../utils/object';\nimport { nextTick } from '../../vue';\nvar OBSERVER_PROP_NAME = '__bv__visibility_observer';\n\nvar VisibilityObserver = /*#__PURE__*/function () {\n  function VisibilityObserver(el, options) {\n    _classCallCheck(this, VisibilityObserver);\n\n    this.el = el;\n    this.callback = options.callback;\n    this.margin = options.margin || 0;\n    this.once = options.once || false;\n    this.observer = null;\n    this.visible = undefined;\n    this.doneOnce = false; // Create the observer instance (if possible)\n\n    this.createObserver();\n  }\n\n  _createClass(VisibilityObserver, [{\n    key: \"createObserver\",\n    value: function createObserver() {\n      var _this = this;\n\n      // Remove any previous observer\n      if (this.observer) {\n        /* istanbul ignore next */\n        this.stop();\n      } // Should only be called once and `callback` prop should be a function\n\n\n      if (this.doneOnce || !isFunction(this.callback)) {\n        /* istanbul ignore next */\n        return;\n      } // Create the observer instance\n\n\n      try {\n        // Future: Possibly add in other modifiers for left/right/top/bottom\n        // offsets, root element reference, and thresholds\n        this.observer = new IntersectionObserver(this.handler.bind(this), {\n          // `null` = 'viewport'\n          root: null,\n          // Pixels away from view port to consider \"visible\"\n          rootMargin: this.margin,\n          // Intersection ratio of el and root (as a value from 0 to 1)\n          threshold: 0\n        });\n      } catch (_unused) {\n        // No IntersectionObserver support, so just stop trying to observe\n        this.doneOnce = true;\n        this.observer = undefined;\n        this.callback(null);\n        return;\n      } // Start observing in a `$nextTick()` (to allow DOM to complete rendering)\n\n      /* istanbul ignore next: IntersectionObserver not supported in JSDOM */\n\n\n      nextTick(function () {\n        requestAF(function () {\n          // Placed in an `if` just in case we were destroyed before\n          // this `requestAnimationFrame` runs\n          if (_this.observer) {\n            _this.observer.observe(_this.el);\n          }\n        });\n      });\n    }\n    /* istanbul ignore next */\n\n  }, {\n    key: \"handler\",\n    value: function handler(entries) {\n      var entry = entries ? entries[0] : {};\n      var isIntersecting = Boolean(entry.isIntersecting || entry.intersectionRatio > 0.0);\n\n      if (isIntersecting !== this.visible) {\n        this.visible = isIntersecting;\n        this.callback(isIntersecting);\n\n        if (this.once && this.visible) {\n          this.doneOnce = true;\n          this.stop();\n        }\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      /* istanbul ignore next */\n      this.observer && this.observer.disconnect();\n      this.observer = null;\n    }\n  }]);\n\n  return VisibilityObserver;\n}();\n\nvar destroy = function destroy(el) {\n  var observer = el[OBSERVER_PROP_NAME];\n\n  if (observer && observer.stop) {\n    observer.stop();\n  }\n\n  delete el[OBSERVER_PROP_NAME];\n};\n\nvar bind = function bind(el, _ref) {\n  var value = _ref.value,\n      modifiers = _ref.modifiers;\n  // `value` is the callback function\n  var options = {\n    margin: '0px',\n    once: false,\n    callback: value\n  }; // Parse modifiers\n\n  keys(modifiers).forEach(function (mod) {\n    /* istanbul ignore else: Until <b-img-lazy> is switched to use this directive */\n    if (RX_DIGITS.test(mod)) {\n      options.margin = \"\".concat(mod, \"px\");\n    } else if (mod.toLowerCase() === 'once') {\n      options.once = true;\n    }\n  }); // Destroy any previous observer\n\n  destroy(el); // Create new observer\n\n  el[OBSERVER_PROP_NAME] = new VisibilityObserver(el, options); // Store the current modifiers on the object (cloned)\n\n  el[OBSERVER_PROP_NAME]._prevModifiers = clone(modifiers);\n}; // When the directive options may have been updated (or element)\n\n\nvar componentUpdated = function componentUpdated(el, _ref2, vnode) {\n  var value = _ref2.value,\n      oldValue = _ref2.oldValue,\n      modifiers = _ref2.modifiers;\n  // Compare value/oldValue and modifiers to see if anything has changed\n  // and if so, destroy old observer and create new observer\n\n  /* istanbul ignore next */\n  modifiers = clone(modifiers);\n  /* istanbul ignore next */\n\n  if (el && (value !== oldValue || !el[OBSERVER_PROP_NAME] || !looseEqual(modifiers, el[OBSERVER_PROP_NAME]._prevModifiers))) {\n    // Re-bind on element\n    bind(el, {\n      value: value,\n      modifiers: modifiers\n    }, vnode);\n  }\n}; // When directive un-binds from element\n\n\nvar unbind = function unbind(el) {\n  // Remove the observer\n  destroy(el);\n}; // Export the directive\n\n\nexport var VBVisible = {\n  bind: bind,\n  componentUpdated: componentUpdated,\n  unbind: unbind\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}